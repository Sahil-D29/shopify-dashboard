export const dynamic = 'force-dynamic';
import { NextRequest, NextResponse } from 'next/server';

import { saveJourneyVersion } from '@/lib/journey-engine/versioning';
import type { JourneyConfig, JourneyDefinition, JourneyStats } from '@/lib/types/journey';
import { readJsonFile, writeJsonFile } from '@/lib/utils/json-storage';

export const runtime = 'nodejs';

const defaultConfig: JourneyConfig = {
  reEntryRules: {
    allow: false,
    cooldownDays: 0,
  },
  maxEnrollments: null,
  timezone: 'UTC',
};

const defaultStats: JourneyStats = {
  totalEnrollments: 0,
  activeEnrollments: 0,
  completedEnrollments: 0,
  goalConversionRate: 0,
};

function withJourneyDefaults(journey: JourneyDefinition): JourneyDefinition {
  const config: JourneyConfig = {
    ...defaultConfig,
    ...(journey.config || {}),
    reEntryRules: {
      ...defaultConfig.reEntryRules,
      ...(journey.config?.reEntryRules || {}),
    },
  };

  if (config.maxEnrollments !== null) {
    const numeric = Number(config.maxEnrollments);
    config.maxEnrollments = Number.isFinite(numeric) ? numeric : null;
  }

  const stats: JourneyStats = {
    ...defaultStats,
    ...(journey.stats || {}),
  };

  const createdAt = journey.createdAt ?? new Date().toISOString();
  const updatedAt = journey.updatedAt ?? createdAt;

  return {
    ...journey,
    createdAt,
    updatedAt,
    config,
    stats,
  };
}

const getErrorMessage = (error: unknown): string => (error instanceof Error ? error.message : String(error));

const normaliseNodes = (nodes: unknown): JourneyDefinition['nodes'] =>
  Array.isArray(nodes) ? (nodes as JourneyDefinition['nodes']) : [];

const normaliseEdges = (edges: unknown): JourneyDefinition['edges'] =>
  Array.isArray(edges) ? (edges as JourneyDefinition['edges']) : [];

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolved = await params;
    const journeys = readJsonFile<JourneyDefinition>('journeys.json');
    const journey = journeys.find(j => j.id === resolved.id);
    if (!journey) return NextResponse.json({ error: 'Not found' }, { status: 404 });
    return NextResponse.json({ journey: withJourneyDefaults(journey) });
  } catch (error) {
    console.error('[journeys][GET]', error);
    return NextResponse.json({ error: getErrorMessage(error) }, { status: 500 });
  }
}

export async function PUT(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolved = await params;
    const updates = (await request.json()) as Partial<JourneyDefinition>;
    const journeys = readJsonFile<JourneyDefinition>('journeys.json');
    const idx = journeys.findIndex(j => j.id === resolved.id);
    if (idx === -1) return NextResponse.json({ error: 'Not found' }, { status: 404 });
    const existing = journeys[idx];

    saveJourneyVersion(existing, {
      label: `${existing.name || 'Journey'} (auto save)` ,
      summary: 'Snapshot before update',
      autoGenerated: true,
    });

    const updated: JourneyDefinition = {
      ...existing,
      ...updates,
      updatedAt: new Date().toISOString(),
      nodes: updates.nodes ? normaliseNodes(updates.nodes) : existing.nodes,
      edges: updates.edges ? normaliseEdges(updates.edges) : existing.edges,
    };
    journeys[idx] = withJourneyDefaults(updated);
    writeJsonFile('journeys.json', journeys);
    return NextResponse.json({ journey: journeys[idx] });
  } catch (error) {
    console.error('[journeys][PUT]', error);
    return NextResponse.json({ error: getErrorMessage(error) }, { status: 500 });
  }
}

export async function DELETE(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const resolved = await params;
    const journeys = readJsonFile<JourneyDefinition>('journeys.json');
    const next = journeys.filter(j => j.id !== resolved.id);
    if (next.length === journeys.length) return NextResponse.json({ error: 'Not found' }, { status: 404 });
    writeJsonFile('journeys.json', next);
    return NextResponse.json({ success: true });
  } catch (error) {
    console.error('[journeys][DELETE]', error);
    return NextResponse.json({ error: getErrorMessage(error) }, { status: 500 });
  }
}


