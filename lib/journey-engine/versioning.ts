import fs from 'fs';
import path from 'path';
import { randomUUID } from 'crypto';

import type { JourneyDefinition } from '@/lib/types/journey';
import type { JourneyVersion, JourneyVersionMetadata } from '@/lib/types/journey-version';
import { getDataFilePath, readJsonFile, writeJsonFile } from '@/lib/utils/json-storage';

import { getJourneys, saveJourneys } from './storage';

const VERSION_DIRECTORY = 'journey-versions';
const MAX_VERSIONS = 50;

type SaveOptions = {
  label?: string;
  summary?: string;
  createdBy?: string;
  autoGenerated?: boolean;
};

const isRecord = (value: unknown): value is Record<string, unknown> =>
  typeof value === 'object' && value !== null && !Array.isArray(value);

const toTrimmedString = (value: unknown): string | undefined => {
  if (typeof value !== 'string') return undefined;
  const trimmed = value.trim();
  return trimmed.length > 0 ? trimmed : undefined;
};

const toBoolean = (value: unknown): boolean | undefined => {
  if (typeof value === 'boolean') return value;
  if (typeof value === 'string') {
    if (value === 'true') return true;
    if (value === 'false') return false;
  }
  return undefined;
};

const toTimestamp = (value: unknown): number | undefined => {
  if (typeof value === 'number' && Number.isFinite(value)) return value;
  if (typeof value === 'string') {
    const parsed = Number(value);
    if (Number.isFinite(parsed)) return parsed;
  }
  return undefined;
};

function ensureJourneyVersionFile(journeyId: string): string {
  const dataDir = getDataFilePath('');
  const versionDir = path.join(dataDir, VERSION_DIRECTORY);
  try {
    if (!fs.existsSync(versionDir)) {
      fs.mkdirSync(versionDir, { recursive: true });
    }
  } catch (error) {
    throw new Error(`Failed to create version directory: ${String(error)}`);
  }

  const relativePath = `${VERSION_DIRECTORY}/${journeyId}.json`;
  const absolutePath = path.join(versionDir, `${journeyId}.json`);

  if (!fs.existsSync(absolutePath)) {
    try {
      fs.writeFileSync(absolutePath, '[]', 'utf-8');
    } catch (error) {
      throw new Error(`Failed to initialise version file for journey ${journeyId}: ${String(error)}`);
    }
  }

  return relativePath;
}

function normaliseJourneyVersion(raw: unknown): JourneyVersion | null {
  if (!isRecord(raw)) return null;
  const id = toTrimmedString(raw.id);
  const journeyId = toTrimmedString(raw.journeyId);
  const label = toTrimmedString(raw.label) ?? 'Untitled Journey';
  const createdAt = toTimestamp(raw.createdAt) ?? Date.now();
  const snapshot = raw.snapshot;

  if (!id || !journeyId || !snapshot || !isRecord(snapshot)) {
    return null;
  }

  const version: JourneyVersion = {
    id,
    journeyId,
    label,
    createdAt,
    snapshot: snapshot as unknown as JourneyDefinition,
  };

  const summary = toTrimmedString(raw.summary);
  if (summary) version.summary = summary;

  const createdBy = toTrimmedString(raw.createdBy);
  if (createdBy) version.createdBy = createdBy;

  const autoGenerated = toBoolean(raw.autoGenerated);
  if (typeof autoGenerated !== 'undefined') version.autoGenerated = autoGenerated;

  return version;
}

function loadVersions(journeyId: string): JourneyVersion[] {
  const relativePath = ensureJourneyVersionFile(journeyId);
  const raw = readJsonFile<unknown>(relativePath);
  if (!Array.isArray(raw)) {
    return [];
  }
  return raw
    .map(normaliseJourneyVersion)
    .filter((version): version is JourneyVersion => Boolean(version))
    .sort((a, b) => b.createdAt - a.createdAt);
}

function persistVersions(journeyId: string, versions: JourneyVersion[]): void {
  const relativePath = ensureJourneyVersionFile(journeyId);
  writeJsonFile(relativePath, versions);
}

function cloneJourney(journey: JourneyDefinition): JourneyDefinition {
  const globalClone = (globalThis as { structuredClone?: <T>(value: T) => T }).structuredClone;
  if (typeof globalClone === 'function') {
    return globalClone(journey);
  }
  return JSON.parse(JSON.stringify(journey)) as JourneyDefinition;
}

export function listJourneyVersions(journeyId: string): JourneyVersion[] {
  return loadVersions(journeyId);
}

export function listJourneyVersionMetadata(journeyId: string): JourneyVersionMetadata[] {
  return listJourneyVersions(journeyId).map(version => ({
    id: version.id,
    journeyId: version.journeyId,
    label: version.label,
    summary: version.summary,
    createdAt: version.createdAt,
    createdBy: version.createdBy,
    autoGenerated: version.autoGenerated,
    stats: {
      nodeCount: version.snapshot.nodes.length,
      edgeCount: version.snapshot.edges.length,
      status: version.snapshot.status,
    },
  }));
}

export function getJourneyVersion(journeyId: string, versionId: string): JourneyVersion | null {
  return loadVersions(journeyId).find(version => version.id === versionId) ?? null;
}

export function saveJourneyVersion(
  journey: JourneyDefinition,
  { label, summary, createdBy, autoGenerated }: SaveOptions = {},
): JourneyVersion {
  const versions = loadVersions(journey.id);

  const version: JourneyVersion = {
    id: randomUUID(),
    journeyId: journey.id,
    label: toTrimmedString(label) ?? journey.name ?? 'Untitled Journey',
    summary: toTrimmedString(summary),
    createdAt: Date.now(),
    createdBy: toTrimmedString(createdBy),
    autoGenerated,
    snapshot: cloneJourney(journey),
  };

  versions.unshift(version);
  if (versions.length > MAX_VERSIONS) {
    versions.length = MAX_VERSIONS;
  }

  persistVersions(journey.id, versions);
  return version;
}

export function deleteJourneyVersion(journeyId: string, versionId: string): boolean {
  const versions = loadVersions(journeyId);
  const next = versions.filter(version => version.id !== versionId);
  if (next.length === versions.length) {
    return false;
  }
  persistVersions(journeyId, next);
  return true;
}

export function restoreJourneyVersion(journeyId: string, versionId: string): JourneyDefinition {
  const version = getJourneyVersion(journeyId, versionId);
  if (!version) {
    throw new Error('Version not found');
  }

  const journeys = getJourneys();
  const idx = journeys.findIndex(journey => journey.id === journeyId);
  if (idx === -1) {
    throw new Error('Journey not found');
  }

  const existing = journeys[idx];

  saveJourneyVersion(existing, {
    label: `${existing.name || 'Journey'} (pre-restore)`,
    summary: `Snapshot before restoring version "${version.label}"`,
    autoGenerated: true,
  });

  const restoredSnapshot = cloneJourney(version.snapshot);
  const restored: JourneyDefinition = {
    ...existing,
    ...restoredSnapshot,
    id: existing.id,
    createdAt: existing.createdAt,
    updatedAt: Date.now(),
  };

  journeys[idx] = restored;
  saveJourneys(journeys);

  return restored;
}

export function clearJourneyVersions(journeyId: string): void {
  persistVersions(journeyId, []);
}
