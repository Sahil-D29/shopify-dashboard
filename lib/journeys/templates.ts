import { v4 as uuid } from 'uuid';

import type {
  JourneyConfig,
  JourneyDefinition,
  JourneyEdge,
  JourneyNode,
  JourneyStats,
  ConditionNode,
} from '@/lib/types/journey';
import type { JourneyTemplate, JourneyTemplateDefinition, JourneyTemplateNode } from '@/lib/types/journey-template';
import { readJsonFile, writeJsonFile } from '@/lib/utils/json-storage';
import { saveJourneyVersion } from '@/lib/journey-engine/versioning';

interface CreateJourneyOptions {
  name?: string;
}

export function loadJourneyTemplates(): JourneyTemplate[] {
  return readJsonFile<JourneyTemplate>('journey-templates.json');
}

export function saveJourneyDefinition(journey: JourneyDefinition): void {
  const journeys = readJsonFile<JourneyDefinition>('journeys.json');

  const config: JourneyConfig = {
    reEntryRules: {
      allow: journey.config?.reEntryRules?.allow ?? false,
      cooldownDays: journey.config?.reEntryRules?.cooldownDays ?? 0,
    },
    maxEnrollments: journey.config?.maxEnrollments ?? null,
    timezone: journey.config?.timezone || journey.settings?.timezone || 'UTC',
    ...(journey.config || {}),
  };

  const stats: JourneyStats = {
    totalEnrollments: journey.stats?.totalEnrollments ?? 0,
    activeEnrollments: journey.stats?.activeEnrollments ?? 0,
    completedEnrollments: journey.stats?.completedEnrollments ?? 0,
    goalConversionRate: journey.stats?.goalConversionRate ?? 0,
    ...(journey.stats || {}),
  };

  const hydrated: JourneyDefinition = {
    ...journey,
    config,
    stats,
  };

  journeys.push(hydrated);
  writeJsonFile('journeys.json', journeys);
  saveJourneyVersion(hydrated, {
    label: `${hydrated.name || 'Journey'} (initial)` ,
    summary: 'Initial version created on import',
    autoGenerated: true,
  });
}

export function createJourneyDefinitionFromTemplate(
  template: JourneyTemplate,
  options: CreateJourneyOptions = {}
): JourneyDefinition {
  const now = Date.now();
  const journeyId = uuid();

  const { nodes, edges } = mapTemplateToGraph(template.journey);
  const defaultConfig: JourneyConfig = {
    reEntryRules: {
      allow: false,
      cooldownDays: 0,
    },
    maxEnrollments: null,
    timezone: typeof template.journey.settings?.timezone === 'string' ? template.journey.settings.timezone : 'UTC',
  };

  const templateConfig = (template.journey as unknown as { config?: Partial<JourneyConfig> })?.config;

  const stats: JourneyStats = {
    totalEnrollments: 0,
    activeEnrollments: 0,
    completedEnrollments: 0,
    goalConversionRate: 0,
  };

  return {
    id: journeyId,
    name: options.name?.trim() || `${template.name} - ${new Date().toLocaleDateString()}`,
    description: template.description,
    status: 'DRAFT',
    createdAt: now,
    updatedAt: now,
    settings: template.journey.settings as JourneyDefinition['settings'],
    config: {
      ...defaultConfig,
      ...(templateConfig || {}),
      reEntryRules: {
        ...defaultConfig.reEntryRules,
        ...(templateConfig?.reEntryRules || {}),
      },
    },
    stats,
    createdFromTemplate: template.id,
    nodes,
    edges,
  } satisfies JourneyDefinition;
}

function mapTemplateToGraph(definition: JourneyTemplateDefinition): { nodes: JourneyNode[]; edges: JourneyEdge[] } {
  const nodes: JourneyNode[] = [];
  const idMap = new Map<string, string>();

  if (definition.trigger) {
    const triggerNode = createNodeFromTemplate(definition.trigger, 'trigger');
    nodes.push(triggerNode);
    idMap.set(definition.trigger.id ?? 'trigger', triggerNode.id);
  }

  for (const node of definition.nodes || []) {
    const created = createNodeFromTemplate(node, node.type);
    nodes.push(created);
    if (node.id) {
      idMap.set(node.id, created.id);
    }
  }

  const edges: JourneyEdge[] = (definition.edges || []).map((edge, index) => ({
    id: edge.id ?? `edge_${index}_${uuid()}`,
    source: idMap.get(edge.source) || edge.source,
    target: idMap.get(edge.target) || edge.target,
    label: edge.label,
  }));

  return { nodes, edges };
}

function createNodeFromTemplate(templateNode: JourneyTemplateNode, type: JourneyNode['type']): JourneyNode {
  const id = templateNode.id ? `node_${templateNode.id}_${uuid()}` : `node_${uuid()}`;
  const position = templateNode.position ?? { x: 200, y: 200 };
  const common = {
    id,
    position,
    name: templateNode.name,
    description: templateNode.description,
    data: templateNode.data ? { ...templateNode.data } : {},
  };

  switch (type) {
    case 'trigger': {
      const triggerSubtype = templateNode.subtype || 'manual_entry';
      return {
        ...common,
        type: 'trigger',
        subtype: triggerSubtype,
        trigger: {
          type: mapSubtypeToTriggerType(triggerSubtype),
          segmentId: toOptionalString(templateNode.data?.segmentId),
          tag: toOptionalString(templateNode.data?.tag),
          productId: toOptionalString(templateNode.data?.productId),
          hours: toOptionalNumber(templateNode.data?.hours),
          webhookEvent: toOptionalString(templateNode.data?.eventName),
        },
      };
    }
    case 'action': {
      return {
        ...common,
        type: 'action',
        subtype: templateNode.subtype || 'send_whatsapp',
        action: {
          kind: (typeof templateNode.data?.kind === 'string' ? templateNode.data.kind : 'whatsapp_template') as 'whatsapp_template',
          templateName: typeof templateNode.data?.templateName === 'string' ? templateNode.data.templateName : (typeof templateNode.name === 'string' ? templateNode.name : 'Message'),
          language: typeof templateNode.data?.templateLanguage === 'string' ? templateNode.data.templateLanguage : 'en',
          variables: toVariablesMap(templateNode.data?.variables),
          sendWindow:
            templateNode.data?.sendWindowStart || templateNode.data?.sendWindowEnd
              ? {
                  startHour: toHour(templateNode.data?.sendWindowStart) ?? 9,
                  endHour: toHour(templateNode.data?.sendWindowEnd) ?? 21,
                }
              : undefined,
          fallbackText: toOptionalString(templateNode.data?.fallbackText),
        },
      };
    }
    case 'delay': {
      return {
        ...common,
        type: 'delay',
        subtype: templateNode.subtype || 'fixed_delay',
        delay: {
          unit: (templateNode.data?.unit as 'minutes' | 'hours' | 'days') || 'hours',
          value: Number(templateNode.data?.duration ?? 24),
        },
      };
    }
    case 'condition': {
      return {
        ...common,
        type: 'condition',
        subtype: templateNode.subtype || 'if_else',
        condition: {
          kind: toConditionKind(templateNode.data?.conditionType),
          args: toRecord(templateNode.data?.args),
        },
      };
    }
    case 'goal': {
      return {
        ...common,
        type: 'goal',
        subtype: templateNode.subtype || 'goal_achieved',
        goal: {
          description:
            toOptionalString(templateNode.data?.goalDescription) || templateNode.description || templateNode.name,
        },
      };
    }
    case 'exit':
    default: {
      return {
        ...common,
        type: 'exit',
        subtype: templateNode.subtype || 'exit_journey',
      };
    }
  }
}

function toOptionalString(value: unknown): string | undefined {
  if (typeof value === 'string' && value.trim().length > 0) {
    return value;
  }
  return undefined;
}

function toOptionalNumber(value: unknown): number | undefined {
  const numeric = Number(value);
  return Number.isFinite(numeric) ? numeric : undefined;
}

function toVariablesMap(value: unknown): Record<string, string> {
  if (!value || typeof value !== 'object') return {};
  return Object.entries(value as Record<string, unknown>).reduce<Record<string, string>>((acc, [key, val]) => {
    if (typeof val === 'string') {
      acc[key] = val;
    } else if (val != null) {
      acc[key] = String(val);
    }
    return acc;
  }, {});
}

function toConditionKind(value: unknown): ConditionNode['condition']['kind'] {
  if (typeof value === 'string') {
    const lower = value.toLowerCase();
    const mapping: Record<string, ConditionNode['condition']['kind']> = {
      opened_message: 'opened_message',
      clicked_link: 'clicked_link',
      made_purchase: 'made_purchase',
      has_tag: 'has_tag',
      total_spent_gt: 'total_spent_gt',
      order_count: 'order_count',
      product_purchased: 'product_purchased',
      custom_condition: 'custom_condition',
    };
    return mapping[lower] ?? 'custom_condition';
  }
  return 'custom_condition';
}

function toRecord(value: unknown): Record<string, unknown> {
  if (!value || typeof value !== 'object' || Array.isArray(value)) {
    return {};
  }
  return { ...(value as Record<string, unknown>) };
}

function mapSubtypeToTriggerType(subtype?: string) {
  switch (subtype) {
    case 'segment_joined':
      return 'segment';
    case 'event_trigger':
      return 'webhook';
    case 'abandoned_cart':
      return 'abandoned_cart';
    case 'order_placed':
      return 'order_placed';
    case 'custom_date':
      return 'custom_date';
    case 'manual_entry':
    default:
      return 'manual';
  }
}

function toHour(value?: unknown): number | undefined {
  if (typeof value !== 'string') return undefined;
  const [hour] = value.split(':');
  const parsed = Number(hour);
  return Number.isFinite(parsed) ? parsed : undefined;
}

